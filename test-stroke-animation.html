<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanji Stroke Animation Test</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #1a1a2e;
      color: white;
    }
    h1 {
      margin-bottom: 20px;
    }
    .container {
      background: #16213e;
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    .svg-container {
      width: 300px;
      height: 300px;
      background: #f5f5f5;
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
    }
    .svg-container svg {
      width: 250px;
      height: 250px;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .play-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .reset-btn {
      background: #4a5568;
      color: white;
    }
    .info {
      margin-top: 20px;
      padding: 15px;
      background: #0f3460;
      border-radius: 8px;
      font-size: 14px;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <h1>Kanji Stroke Animation Test</h1>

  <div class="container">
    <div class="svg-container" id="svgContainer">
      <!-- SVG will be loaded here -->
    </div>

    <div style="text-align: center;">
      <button class="play-btn" onclick="playAnimation()">▶ Play Animation</button>
      <button class="reset-btn" onclick="resetSvg()">↺ Reset</button>
    </div>

    <div class="info">
      <strong>Technique:</strong> Two-layer approach - gray background strokes with colored strokes animating on top using stroke-dashoffset.
    </div>
  </div>

  <script>
    // Color palette for strokes
    const STROKE_COLORS = [
      '#3b82f6', // blue
      '#ef4444', // red
      '#22c55e', // green
      '#a855f7', // purple
      '#f97316', // orange
      '#06b6d4', // cyan
      '#ec4899', // pink
      '#eab308', // yellow
      '#6366f1', // indigo
      '#10b981', // emerald
      '#f59e0b', // amber
      '#8b5cf6', // violet
    ];

    // Embedded SVG (the downloaded kanji)
    const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 109 109" class="kan-g"><g class="kgPaths" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M17.88 37.23c2.13.54 5.78.58 7.89.29 17.48-2.39 35.98-4.39 54.65-5.48 3.54-.21 5.68.01 7.46.28" stroke="#2563eb" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M48.22 14.14c.53 2.11.53 4.3.31 6.73C47 38 33 72.5 15.5 85.25" stroke="#dc2626" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M42.66 54.86c1.09.27 2.51.28 3.59.14 6.88-.88 16.62-3.25 22.43-4.88 3.45-.97 4.6 1.45 3.11 4.55C66.5 65.62 48.12 87.75 24 96.5" stroke="#16a34a" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M41.25 63.5c5.15.45 27.5 18.62 40.93 26.36 3.2 1.84 6.65 3.76 10.32 4.39" stroke="#9333ea" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></g></svg>`;

    let animationId = null;
    let isAnimating = false;

    // Initialize SVG with colors
    function initSvg() {
      const container = document.getElementById('svgContainer');
      container.innerHTML = svgContent;

      const svg = container.querySelector('svg');

      // Remove stroke numbers
      const numbersGroup = svg.querySelector('.kgNumbers');
      if (numbersGroup) numbersGroup.remove();

      // Remove inherited stroke from group
      const kgPaths = svg.querySelector('.kgPaths');
      if (kgPaths) kgPaths.removeAttribute('stroke');

      // Apply colors to paths
      const paths = svg.querySelectorAll('.kgPaths path');
      paths.forEach((path, index) => {
        const color = STROKE_COLORS[index % STROKE_COLORS.length];
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '4');
        path.setAttribute('fill', 'none');
      });
    }

    // Reset to initial state
    function resetSvg() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      isAnimating = false;
      initSvg();
    }

    // Play stroke animation - two layer approach
    function playAnimation() {
      if (isAnimating) return;

      const container = document.getElementById('svgContainer');
      const svg = container.querySelector('svg');
      const kgPaths = svg.querySelector('.kgPaths');
      const paths = Array.from(kgPaths.querySelectorAll('path'));

      if (paths.length === 0) {
        console.error('No paths found!');
        return;
      }

      isAnimating = true;

      // Store original colors and set paths to gray (background)
      const originalColors = paths.map(p => p.getAttribute('stroke'));
      paths.forEach(path => {
        path.setAttribute('stroke', '#e0e0e0');
      });

      // Create overlay group for colored animated strokes
      const animGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      animGroup.setAttribute('class', 'animation-overlay');
      kgPaths.parentNode.appendChild(animGroup);

      // Prepare animated paths - all start hidden
      const animData = paths.map((path, index) => {
        const clone = path.cloneNode(true);
        const length = path.getTotalLength();

        clone.setAttribute('stroke', originalColors[index]);
        clone.setAttribute('stroke-width', '4');
        clone.setAttribute('fill', 'none');
        clone.setAttribute('stroke-linecap', 'round');
        clone.setAttribute('stroke-linejoin', 'round');
        clone.style.strokeDasharray = String(length);
        clone.style.strokeDashoffset = String(length); // Fully hidden

        animGroup.appendChild(clone);

        return {
          element: clone,
          length: length,
          originalPath: path,
          originalColor: originalColors[index]
        };
      });

      // Animation state
      const strokeDuration = 400; // ms per stroke
      const pauseBetween = 80; // ms pause between strokes
      let currentStroke = 0;
      let strokeProgress = 0;
      let lastTimestamp = null;
      let isPausing = false;
      let pauseEndTime = 0;

      function animate(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = timestamp - lastTimestamp;
        lastTimestamp = timestamp;

        // Handle pause between strokes
        if (isPausing) {
          if (timestamp >= pauseEndTime) {
            isPausing = false;
            currentStroke++;
            strokeProgress = 0;
          } else {
            animationId = requestAnimationFrame(animate);
            return;
          }
        }

        // Check if animation complete
        if (currentStroke >= animData.length) {
          // Clean up - remove overlay, restore colors
          animGroup.remove();
          paths.forEach((path, index) => {
            path.setAttribute('stroke', originalColors[index]);
          });
          isAnimating = false;
          return;
        }

        // Animate current stroke
        const { element, length } = animData[currentStroke];
        strokeProgress += deltaTime / strokeDuration;

        if (strokeProgress >= 1) {
          // Stroke complete
          element.style.strokeDashoffset = '0';
          isPausing = true;
          pauseEndTime = timestamp + pauseBetween;
        } else {
          // Draw stroke progressively
          const offset = length * (1 - strokeProgress);
          element.style.strokeDashoffset = String(offset);
        }

        animationId = requestAnimationFrame(animate);
      }

      // Start animation
      animationId = requestAnimationFrame(animate);
    }

    // Initialize on load
    window.onload = initSvg;
  </script>
</body>
</html>
