<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanji Stroke Animation Test</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #1a1a2e;
      color: white;
    }
    h1 {
      margin-bottom: 20px;
    }
    .container {
      background: #16213e;
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    .svg-container {
      width: 300px;
      height: 300px;
      background: #f5f5f5;
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
    }
    .svg-container svg {
      width: 250px;
      height: 250px;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .play-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .reset-btn {
      background: #4a5568;
      color: white;
    }
    .info {
      margin-top: 20px;
      padding: 15px;
      background: #0f3460;
      border-radius: 8px;
      font-size: 14px;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <h1>Kanji Stroke Animation Test</h1>

  <div class="container">
    <div class="svg-container" id="svgContainer">
      <!-- SVG will be loaded here -->
    </div>

    <div style="text-align: center;">
      <button class="play-btn" onclick="playAnimation()">▶ Play Animation</button>
      <button class="reset-btn" onclick="resetSvg()">↺ Reset</button>
    </div>

    <div class="info">
      <strong>Technique:</strong> Two-layer approach - gray background strokes with colored strokes animating on top using stroke-dashoffset.
    </div>
  </div>

  <script>
    // Color palette for strokes
    const STROKE_COLORS = [
      '#3b82f6', // blue
      '#ef4444', // red
      '#22c55e', // green
      '#a855f7', // purple
      '#f97316', // orange
      '#06b6d4', // cyan
      '#ec4899', // pink
      '#eab308', // yellow
      '#6366f1', // indigo
      '#10b981', // emerald
      '#f59e0b', // amber
      '#8b5cf6', // violet
    ];

    // Embedded SVG (the downloaded kanji)
    const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 109 109" class="kan-g"><g class="kgPaths" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M53.06 13.73c.92.92 1.63 2.6 1.6 3.75-.09 3.62-.09 7.03-.09 10.33" stroke="#2563eb" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M26.67 28.85c0 3.6-3.32 13.5-4.83 15.9" stroke="#dc2626" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M27.53 30.96c12.72-1.58 40.97-4.21 54.14-4.86 9.82-.48 1.45 6.65-2.17 9.9" stroke="#16a34a" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M49.87 36.87c.51 1.45.52 3.55 0 5.32-2.74 9.22-7.03 20.09-13.85 30.42-1.43 2.17-.76 2.95 1.26 3.14 8.23.75 21.61 4.5 33.74 11.77 4.36 2.61 8.24 5.98 10.24 9.48" stroke="#9333ea" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M70 50c.38 1.48.22 3.46-.26 5.13-3.88 13.52-17.45 34.6-43.24 42.49" stroke="#ea580c" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path><path d="M15.13 60.22c2.85.74 6.22.42 9.12.2 11.33-.85 40.73-4.55 64.72-4.64 2.27-.01 6.19.33 8.03.96" stroke="#0891b2" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></g></svg>`;

    let animationId = null;
    let isAnimating = false;

    // Initialize SVG with colors
    function initSvg() {
      const container = document.getElementById('svgContainer');
      container.innerHTML = svgContent;

      const svg = container.querySelector('svg');

      // Remove stroke numbers
      const numbersGroup = svg.querySelector('.kgNumbers');
      if (numbersGroup) numbersGroup.remove();

      // Remove inherited stroke from group
      const kgPaths = svg.querySelector('.kgPaths');
      if (kgPaths) kgPaths.removeAttribute('stroke');

      // Apply colors to paths
      const paths = svg.querySelectorAll('.kgPaths path');
      paths.forEach((path, index) => {
        const color = STROKE_COLORS[index % STROKE_COLORS.length];
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '4');
        path.setAttribute('fill', 'none');
      });
    }

    // Reset to initial state
    function resetSvg() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      isAnimating = false;
      initSvg();
    }

    // Play stroke animation - two layer approach
    function playAnimation() {
      if (isAnimating) return;

      const container = document.getElementById('svgContainer');
      const svg = container.querySelector('svg');
      const kgPaths = svg.querySelector('.kgPaths');
      const paths = Array.from(kgPaths.querySelectorAll('path'));

      if (paths.length === 0) {
        console.error('No paths found!');
        return;
      }

      isAnimating = true;

      // Store original colors and set paths to gray (background)
      const originalColors = paths.map(p => p.getAttribute('stroke'));
      paths.forEach(path => {
        path.setAttribute('stroke', '#e0e0e0');
      });

      // Create overlay group for colored animated strokes
      const animGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      animGroup.setAttribute('class', 'animation-overlay');
      kgPaths.parentNode.appendChild(animGroup);

      // Prepare animated paths - all start hidden
      const animData = paths.map((path, index) => {
        const clone = path.cloneNode(true);
        const length = path.getTotalLength();

        clone.setAttribute('stroke', originalColors[index]);
        clone.setAttribute('stroke-width', '4');
        clone.setAttribute('fill', 'none');
        clone.setAttribute('stroke-linecap', 'round');
        clone.setAttribute('stroke-linejoin', 'round');
        clone.style.strokeDasharray = String(length);
        clone.style.strokeDashoffset = String(length); // Fully hidden

        animGroup.appendChild(clone);

        return {
          element: clone,
          length: length,
          originalPath: path,
          originalColor: originalColors[index]
        };
      });

      // Animation state
      const strokeDuration = 400; // ms per stroke
      const pauseBetween = 80; // ms pause between strokes
      let currentStroke = 0;
      let strokeProgress = 0;
      let lastTimestamp = null;
      let isPausing = false;
      let pauseEndTime = 0;

      function animate(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = timestamp - lastTimestamp;
        lastTimestamp = timestamp;

        // Handle pause between strokes
        if (isPausing) {
          if (timestamp >= pauseEndTime) {
            isPausing = false;
            currentStroke++;
            strokeProgress = 0;
          } else {
            animationId = requestAnimationFrame(animate);
            return;
          }
        }

        // Check if animation complete
        if (currentStroke >= animData.length) {
          // Clean up - remove overlay, restore colors
          animGroup.remove();
          paths.forEach((path, index) => {
            path.setAttribute('stroke', originalColors[index]);
          });
          isAnimating = false;
          return;
        }

        // Animate current stroke
        const { element, length } = animData[currentStroke];
        strokeProgress += deltaTime / strokeDuration;

        if (strokeProgress >= 1) {
          // Stroke complete
          element.style.strokeDashoffset = '0';
          isPausing = true;
          pauseEndTime = timestamp + pauseBetween;
        } else {
          // Draw stroke progressively
          const offset = length * (1 - strokeProgress);
          element.style.strokeDashoffset = String(offset);
        }

        animationId = requestAnimationFrame(animate);
      }

      // Start animation
      animationId = requestAnimationFrame(animate);
    }

    // Initialize on load
    window.onload = initSvg;
  </script>
</body>
</html>
